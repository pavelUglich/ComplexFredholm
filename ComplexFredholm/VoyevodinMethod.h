#pragma once
#include<vector>
#include "MatrixSystem.h"
#include "IterativeProcess.h"
//#include "Stabilizer.h"
using namespace std;

class voyevodin_method
{
	double _alpha_initial_value;//Начальное значение параметра регуляризации
	double step; //длина отрезка разбиения
	double eps;//Погрешность определения параметра регуляризации
	double h; //Погрешность оператора
	double delta;//Погрешность правой части
	vector<complex<double>> RightPart;
	vector<complex<double>> p1;
	vector<complex<double>> p2;
	vector<complex<double>> Qtu;
	size_t _rows;
	size_t _columns;
	vector<complex<double>> _solution;

public:
	//voyevodin_method();

	/// <summary>
	/// Конструктор метода Воеводина
	/// </summary>
	/// <param name="matrix">Матрица СЛАУ;</param>
	/// <param name="rightpart">вектор правой части;</param>
	/// <param name="Step">Длина подотрезка;</param>
	/// <param name="Left">Краевое условие;</param>
	/// <param name="Right">Краевое условие;</param>
	/// <param name="p">Параметр стабилизатора;</param>
	/// <param name="alphaInitialValue">Начальное значение параметра регуляризации;</param>
	/// <param name="H">Погрешность оператора;</param>
	/// <param name="Delta">Погрешность правой части;</param>
	/// <param name="eps">Погрешность определения параметра регуляризации;</param>
	voyevodin_method(const vector<vector<complex<double>>> & matrix,
		const vector<complex<double>> & rightpart,
		double Step,
		BoundaryCondition Left = Neumann,
		BoundaryCondition Right = Neumann,
		double p = 1.0,
		double alphaInitialValue = 0.1e-1,
		double H = 0,
		double Delta = 0,
		double eps = 0.1e-3) :
		RightPart(rightpart), step(Step), _alpha_initial_value(alphaInitialValue), 
		h(H), delta(Delta), eps(eps) {
		//1. Создаём систему и приводим её к двухдиагональному виду
		matrix_system ms = { matrix, RightPart, step, p, Left, Right };
		//2. Запускаем итерационный процесс
		iterative_process iterativeProcess = {
			ms.Diagonal(),
			ms.UpDiagonal(),
			ms.rightPart(),
			ms.multiply_qtu(RightPart),
			_alpha_initial_value, step, h,	delta,	eps };
		//3. Получаем решение
		_solution = iterativeProcess.solution();
		//4. Возвращаемя к изначальным неизвестнымю
		ms.multiply_rtx(_solution);
		ms.multiply_sinv(_solution);
	};


	vector<complex<double>> solution() const {
		return _solution;
	};

};

